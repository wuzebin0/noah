JVM ->JVM内存模型、如何判断对象是否要被回收（引用计数法，可达性分析法(GC ROOTS)）、垃圾回收算法、垃圾收集器
、JVM生命周期、什么时候触发FULLGC、CMS与G1区别、类加载机制、JVM调优、类加载过程、双亲委派机制
 

JMM 内存模型是JVM的一种规范，他定义了在多线程环境下，线程如何与内存交互，以及如何保证线程间的可见性，有序性，原子性。
可见性：一个线程对共享变量的修改，能否被其他线程看到。
有序性：线程的执行顺序有时候跟代码编写的顺序不一致，这是因为编译期跟解释器对指令的重排序。
原子性：有些操作要么成功，要么失败。
JMM 有5大内存区域，包括程序计数器，Java虚拟机栈，堆，方法区，本地方法栈。
程序计数器是一块很小的内存空间，代表着当前线程正在执行的字节码行号指示器，也就是说，程序计数器存储着当前线程正在执行的字节码指令地址。
有两个作用，1是字节码解释器通过改变程序计数器来依次读取字节码执行，从而来控制代码的流程控制；2是记录着当前线程执行的位置，当线程回切后，可以继续执行。
Java虚拟栈是JVM为即将执行的方法开辟的一块栈帧，他存储着局部变量表（方法参数，方法内变量），操作数栈，动态链接
JVM所有的对象都存储在堆中，而方法区是堆的一个逻辑部分，他存储着常量，静态变量，类信息

引用计数法，每个对象都有一个计数器，被引用就加1，引用对象失效就减1，当计数器为0的时候就代表该对象可以被回收，但是不能解决循环依赖问题。
可达性分析法，所有与GC ROOTS有直接或者间接的关系，都是有效对象，GC ROOTS  Java虚拟机栈引用的对象 方法区常量引用的对象  方法区静态变量引用的对象
本地方法栈引用的对象

标记-清除法  复制算法   标记-清理法  分代收集法


------------------------------------------------------------------------------------------------------


使用jstack定位线程堆栈信息:   https://www.javatang.com/archives/2017/10/19/33151873.html

jstack生成的Thread Dump日志结构解析:  https://www.javatang.com/archives/2017/10/19/51301886.html

jstat命令的使用及VM Thread分析   https://www.javatang.com/archives/2017/10/20/12131956.html

jstack生成的Thread Dump日志线程状态   https://www.javatang.com/archives/2017/10/25/36441958.html

常见的Thread Dump日志案例分析   https://www.javatang.com/archives/2017/10/26/08572060.html

JVM Heap Dump（堆转储文件）的生成和MAT的使用    https://www.javatang.com/archives/2017/10/30/53562102.html

使用MAT的Histogram和Dominator Tree定位溢出源    https://www.javatang.com/archives/2017/11/08/11582145.html


怎么通过dump文件，找到年轻代有的对象突然占用内存很高然后又释放，因为每一次dump会触发gc导致没办法定位


 
